"""
ID посылки: 88493919

-- ПРИНЦИП РАБОТЫ --

Принцип работы основан на поисковом индексе.

Получив каждый документ, алгоритм составляет хеш таблицу с ключом по слову в документе, а значением хеш таблецей ключ значение, где ключ - номер документа, а значение количество вхождений слова в документ.
(Получается схема {word : {document : count}})
Таким образом получается определить вхождение каждого слова в каждом документе.

Далее при получении запроса, считывая его в set структуру (множество хранит уникальные элементы), мы составляем хеш таблицу релевантности каждого документа по запросу, где ключ-документ, а значение-его релевантность.

В дальнейшем, производя сортировку данной структуры, получаем рейтинг релевантности документов.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Алгоритм корректно обрабатывает каждое слово, так как сопоставляет слово из запроса хеш таблице по документам.
Алгоритм может допускать ошибку, если слово запроса и слово документа являются однокоренными, но имеют разные окончания (с точки зрения ключей это разные значения, с точки зрения семантики - одни)

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Сложность данного алгоритма описывается O(n+m+n+m), где n - суммарное колиество символов в документах, m - суммарное количество символов в запросе.
Сложность алгоритма состоит в операциях:
- Проход по словам документов для хеш таблицы
- Приведение слов запроса к множеству 
- Проход по множеству слов в запросах 
- Соритовка хеш таблицы в лист

Таким образом сложность O(2n+2m)~O(N)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пространственная сложность -  O(n+m+l+l) памяти.

Где n - кол-во слов документов
    m- кол-во слов в запросах
    l- длина массива ответа

Принято допущение, что массив и хеш таблица с одинаковым количеством элементов занимают одинаковое количество памяти

Таким образом, затраты по памяти O(n+m+2l)~O(N)
"""

import sys

storage = {}

if __name__ == "__main__":

  n = int(input())

  for i in range(n):

    doc = sys.stdin.readline().split()
    j = i + 1
    for word in doc:
      if word in storage:
        cur_word = storage[word]
        if j in cur_word:
          cur_word[j] += 1
        else:
          cur_word[j] = 1
      else:
        storage[word] = {j: 1}

  m = int(input())

  for i in range(m):
    ans = {}
    request = set(sys.stdin.readline().split())

    for req in request:
      if req in storage:
        for k, v in storage[req].items():
          if k in ans:
            ans[k] -= v
          else:
            ans[k] = -v

    sorted_ans = sorted(ans.items(), key=lambda tr: (tr[1], tr[0]))
    out = []

    for num, answer in enumerate(sorted_ans):
      out.append(answer[0])
      if num == 4:
        break
    print(*out)

